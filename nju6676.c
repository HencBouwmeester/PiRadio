#include "nju6676.h"
#include <inttypes.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

// DDRAM copy  (8 pages of 1byte) * (132 columns)
uint8_t DDRAM [1024] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

#ifdef enablePartialUpdate
static uint8_t xUpdateMin, xUpdateMax, yUpdateMin, yUpdateMax;
#endif

static void updateBoundingBox(uint8_t xmin, uint8_t ymin, uint8_t xmax, uint8_t ymax) {
#ifdef enablePartialUpdate
  if (xmin < xUpdateMin) xUpdateMin = xmin;
  if (xmax > xUpdateMax) xUpdateMax = xmax;
  if (ymin < yUpdateMin) yUpdateMin = ymin;
  if (ymax > yUpdateMax) yUpdateMax = ymax;
#endif
}

lcdCoord			nju6676Coord;
uint8_t nju6676Inverted=0;
nju6676FontCallback  nju6676FontRead;
uint8_t              nju6676FontColor;
const char*          nju6676Font;


void nju6676Init(void)
{
	nju6676Coord.x = 0;
	nju6676Coord.y = 0;
	nju6676Coord.page = 0;

	nju6676ResetHW();
	nju6676WriteCommand(0xA2);
	nju6676WriteCommand(0xA0); // ADC select
	nju6676WriteCommand(0xC8); // Common direction select
	nju6676WriteCommand(0x40); // Initial display line set
	nju6676WriteCommand(0x81); // set EVR mode first
	nju6676WriteCommand(0x20); // EVR value
	nju6676WriteCommand(0x2F); // power control set
	nju6676WriteCommand(0xA3); // set bias to 1/7
	nju6676WriteCommand(0xA4); // entire display
	nju6676WriteCommand(0xE7); // driver on
	nju6676WriteCommand(0xAF); // display on
	nju6676WriteCommand(0xB0); // page address set
	nju6676WriteCommand(0x10); // column upper set
	nju6676WriteCommand(0x00); // column lower set

// 	nju6676ClearScreen();
// 	nju6676GotoXY(0,0);
	updateBoundingBox(0,0,SCREEN_WIDTH-1,SCREEN_HEIGHT-1);
}

void nju6676ResetHW( void )
{
	bcm2835_gpio_write(LCD_A0,   LOW);
	bcm2835_gpio_write(LCD_RST,  LOW);
	bcm2835_delay(20);
	bcm2835_gpio_write(LCD_RST, HIGH);
};

void nju6676Backlight( int State )
{
	bcm2835_gpio_write(POWER_EN, State);
};

void nju6676WriteCommand( uint8_t cmd)
{
		bcm2835_gpio_write(LCD_A0, LOW);
		bcm2835_spi_transfer(cmd);
}

void nju6676WriteData( uint8_t data)
{
	uint8_t displayData, yOffset;

	if (nju6676Coord.x >= 128) // we start at 0
		return;

	yOffset = (nju6676Coord.y)%8;
   if(yOffset != 0) {
      // first page
      displayData = nju6676ReadData();

      displayData |= data << yOffset;
		nju6676DoWriteData(displayData);               // write data

      // second page
      nju6676GotoXY(nju6676Coord.x, nju6676Coord.y+8);

      displayData = nju6676ReadData();

      displayData |= data >> (8-yOffset);
		nju6676DoWriteData(displayData);               // write data

      nju6676GotoXY(nju6676Coord.x+1, nju6676Coord.y-8);
   } else {
		nju6676DoWriteData(data);               // write data
      nju6676Coord.x++;
   }
}
	
void nju6676DoWriteData( uint8_t data)
{
// 	printf("%d %d %d : %x, ",nju6676Coord.page, nju6676Coord.x, nju6676Coord.y,data);
// 	printf("%4d, ",nju6676Coord.y*SCREEN_WIDTH + nju6676Coord.x);
	DDRAM[nju6676Coord.page*SCREEN_WIDTH + nju6676Coord.x] = data;
// 	nju6676Coord.x++;
// 	bcm2835_gpio_write(LCD_A0, HIGH);
// 	bcm2835_spi_transfer(data);
}

void nju6676ClearScreen( uint8_t color )
{
	memset(DDRAM, color, 1024);
}

inline uint8_t nju6676ReadData(void)
{
	nju6676GotoXY(nju6676Coord.x, nju6676Coord.y);
// 	printf("%d %d %d, ",nju6676Coord.page, nju6676Coord.x, nju6676Coord.y);
	return DDRAM[nju6676Coord.page*SCREEN_WIDTH + nju6676Coord.x];
}

void nju6676GotoXY(uint8_t x, uint8_t y) {
	if(x >= SCREEN_WIDTH) x = 0;								// ensure that coordinates are legal
	if(y >= SCREEN_HEIGHT)  y = 0;
	
	nju6676Coord.x = x;								// save new coordinates
	nju6676Coord.y = y;
	nju6676Coord.page = y/8;
	
	x+=4;												// Compensate for 3 scratch columns
	nju6676WriteCommand(0x40);					// set initial line
	nju6676WriteCommand(x & 0x0F);					// set x address (lower nibble)
	nju6676WriteCommand(0x10 | ((x & 0xF0) >> 4));					// set x address (upper nibble)

	nju6676WriteCommand(0xB0 | nju6676Coord.page);			// set y address
}

#define absDiff(x,y) ((x>y) ?  (x-y) : (y-x))
#define swap(a,b) \
	do\
{\
	uint8_t t;\
	   t=a;\
	   a=b;\
	   b=t;\
} while(0)

void nju6676DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t color)
{
	uint8_t deltax, deltay, x,y, steep;
	int8_t error, ystep;

   steep = absDiff(y1,y2) > absDiff(x1,x2);

   if ( steep )
   {
      swap(x1, y1);
      swap(x2, y2);
   }

   if (x1 > x2)
   {
      swap(x1, x2);
      swap(y1, y2);
   }

   deltax = x2 - x1;
   deltay = absDiff(y2,y1);
   error = deltax / 2;
   y = y1;
   if(y1 < y2) ystep = 1;  else ystep = -1;

   for(x = x1; x <= x2; x++)
   {
      if (steep) nju6676SetDot(y,x, color); else nju6676SetDot(x,y, color);
         error = error - deltay;
      if (error < 0)
      {
         y = y + ystep;
         error = error + deltax;
      }
   }


}

void nju6676DrawRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t color)
{
   nju6676DrawHLine(x, y, width, color);            // top
   nju6676DrawHLine(x, y+height, width, color);     // bottom
   nju6676DrawVLine(x, y, height, color);           // left
   nju6676DrawVLine(x+width, y, height, color);     // right
}

void nju6676FillRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t color) 
{
	nju6676SetPixels(x,y,x+width,y+height,color);
}

void nju6676SetPixels(uint8_t x, uint8_t y, uint8_t x2, uint8_t y2, uint8_t color) 
{
	uint8_t mask, pageOffset, h, i, data;
	uint8_t height = y2-y+1;
	uint8_t width = x2-x+1;

// 	nju6676WriteCommand(0xAE);
   pageOffset = y%8;
   y -= pageOffset;
   mask = 0xFF;
   if(height < 8-pageOffset) {
      mask >>= (8-height);
      h = height;
   } else {
      h = 8-pageOffset;
   }
   mask <<= pageOffset;

   nju6676GotoXY(x, y);
   for(i=0; i<=width; i++) {
      data = nju6676ReadData();

      if(color == WHITE) {
         data |= mask;
      } else {
         data &= ~mask;
      }

      nju6676WriteData(data);
   }

   while(h+8 <= height) {
      h += 8;
      y += 8;
      nju6676GotoXY(x, y);

      for(i=0; i<=width; i++) {
         nju6676WriteData(color);
      }
   }
   if(h < height) {
      mask = ~(0xFF << (height-h));
      nju6676GotoXY(x, y+8);

      for(i=0; i<=width; i++) {
         data = nju6676ReadData();

         if(color == WHITE) {
            data |= mask;
         } else {
            data &= ~mask;
         }

         nju6676WriteData(data);
      }
   }
// 	nju6676WriteCommand(0xAF);
}

void nju6676DrawHLine(uint8_t x, uint8_t y, uint8_t width, uint8_t color){
    nju6676SetPixels(x,y, x+width, y, color);
}

void nju6676DrawVLine(uint8_t x, uint8_t y, uint8_t height, uint8_t color){
    nju6676SetPixels(x,y, x, y+height, color);
}

void nju6676DrawRoundRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t radius, uint8_t color)
{
	int16_t tSwitch, x1 = 0, y1 = radius;
	tSwitch = 3 - 2 * radius;

	while (x1 <= y1) {
		nju6676SetDot(x+radius - x1, y+radius - y1, color);
		nju6676SetDot(x+radius - y1, y+radius - x1, color);

		nju6676SetDot(x+width-radius + x1, y+radius - y1, color);
		nju6676SetDot(x+width-radius + y1, y+radius - x1, color);

		nju6676SetDot(x+width-radius + x1, y+height-radius + y1, color);
		nju6676SetDot(x+width-radius + y1, y+height-radius + x1, color);

		nju6676SetDot(x+radius - x1, y+height-radius + y1, color);
		nju6676SetDot(x+radius - y1, y+height-radius + x1, color);

		if (tSwitch < 0) {
			tSwitch += (4 * x1 + 6);
		} else {
			tSwitch += (4 * (x1 - y1) + 10);
			y1--;
		}
		x1++;
	}

	nju6676DrawHLine(x+radius, y, width-(2*radius), color);         // top
	nju6676DrawHLine(x+radius, y+height, width-(2*radius), color);  // bottom
	nju6676DrawVLine(x, y+radius, height-(2*radius), color);        // left
	nju6676DrawVLine(x+width, y+radius, height-(2*radius), color);  // right
}

void nju6676DrawCircle(uint8_t xCenter, uint8_t yCenter, uint8_t radius, uint8_t color)
{
	nju6676DrawRoundRect(xCenter-radius, yCenter-radius, 2*radius, 2*radius, radius, color);
}

void nju6676FillCircle(uint8_t xCenter, uint8_t yCenter, uint8_t radius, uint8_t color)
{
	int f = 1 - radius;
	int ddF_x = 1;
	int ddF_y = -2 * radius;
	uint8_t x = 0;
	uint8_t y = radius;

   /*
    * Fill in the center between the two halves
    */
   nju6676DrawLine(xCenter, yCenter-radius, xCenter, yCenter+radius, color);

   while(x < y)
   {
    // ddF_x == 2 * x + 1;
    // ddF_y == -2 * y;
    // f == x*x + y*y - radius*radius + 2*x - y + 1;
      if(f >= 0)
      {
         y--;
         ddF_y += 2;
         f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x;

      /*
       * Now draw vertical lines between the points on the circle rather than
       * draw the points of the circle. This draws lines between the
       * perimeter points on the upper and lower quadrants of the 2 halves of the circle.
       */

      nju6676DrawLine(xCenter+x, yCenter+y, xCenter+x, yCenter-y, color);
      nju6676DrawLine(xCenter-x, yCenter+y, xCenter-x, yCenter-y, color);
      nju6676DrawLine(xCenter+y, yCenter+x, y+xCenter, yCenter-x, color);
      nju6676DrawLine(xCenter-y, yCenter+x, xCenter-y, yCenter-x, color);
   }
}

void nju6676InvertRect(uint8_t x, uint8_t y, uint8_t width, uint8_t height)
{
	uint8_t mask, pageOffset, h, i, data, tmpData;
	height++;

	pageOffset = y%8;
	y -= pageOffset;
	mask = 0xFF;
	if(height < 8-pageOffset) {
		mask >>= (8-height);
		h = height;
	} else {
		h = 8-pageOffset;
	}
	mask <<= pageOffset;

	nju6676GotoXY(x, y);
	for(i=0; i<=width; i++) {
		data = nju6676ReadData();
		tmpData = ~data;
		data = (tmpData & mask) | (data & ~mask);
		nju6676WriteData(data);
	}

	while(h+8 <= height) {
		h += 8;
		y += 8;
		nju6676GotoXY(x, y);

		for(i=0; i<=width; i++) {
			data = nju6676ReadData();
			nju6676WriteData(~data);
		}
	}

	if(h < height) {
		mask = ~(0xFF << (height-h));
		nju6676GotoXY(x, y+8);

		for(i=0; i<=width; i++) {
			data = nju6676ReadData();
			tmpData = ~data;
			data = (tmpData & mask) | (data & ~mask);
			nju6676WriteData(data);
		}
	}
}

void nju6676SetInverted(uint8_t invert)
{
   if(nju6676Inverted != invert) {
      nju6676InvertRect(0,0,127,63);
      nju6676Inverted = invert;
   }
}


void nju6676SetDot(uint8_t x, uint8_t y, uint8_t color)
{
	uint8_t data;

	nju6676GotoXY(x, y-y%8);             // read data from display memory
	data = nju6676ReadData();

	if(color == WHITE) {
		data |= 0x01 << (y%8);           // set dot
	} else {
		data &= ~(0x01 << (y%8));        // clear dot
	}

	nju6676WriteData(data);              // write data back to display
}

uint8_t nju6676ReadFontData(const char* ptr) {
	return *(ptr);
}

void nju6676SelectFont(const char* font, nju6676FontCallback callback, uint8_t color) {
	nju6676Font = font;
	nju6676FontRead = callback;
	nju6676FontColor = color;
}

int nju6676PutChar(char c) {
   uint8_t i, j;
   uint8_t width = 0;
   uint8_t height = nju6676FontRead(nju6676Font+FONT_HEIGHT);
   uint8_t bytes = (height+7)/8;

   uint8_t firstChar = nju6676FontRead(nju6676Font+FONT_FIRST_CHAR);
   uint8_t charCount = nju6676FontRead(nju6676Font+FONT_CHAR_COUNT);

   uint16_t index = 0;
   uint8_t x = nju6676Coord.x, y = nju6676Coord.y;

   if(c < firstChar || c >= (firstChar+charCount)) {
      return 1;
   }
   c-= firstChar;

	if( nju6676FontRead(nju6676Font+FONT_LENGTH) == 0 && nju6676FontRead(nju6676Font+FONT_LENGTH+1) == 0) 
	{
		width = nju6676FontRead(nju6676Font+FONT_FIXED_WIDTH);
		index = c*bytes*width+FONT_WIDTH_TABLE;
	} else {
		// read width data, to get the index
		for(i=0; i<c; i++) {
			index += nju6676FontRead(nju6676Font+FONT_WIDTH_TABLE+i);
		}
		index = index*bytes+charCount+FONT_WIDTH_TABLE;
		width = nju6676FontRead(nju6676Font+FONT_WIDTH_TABLE+c);
	}

   // last but not least, draw the character
   for(i=0; i<bytes; i++) {
      uint8_t page = i*width;
      for(j=0; j<width; j++) {
         uint8_t data = nju6676FontRead(nju6676Font+index+page+j);

         if(height > 8 && height < (i+1)*8) {
            data >>= (i+1)*8-height;
         }

         if(nju6676FontColor == WHITE) {
            nju6676WriteData(data);
         } else {
            nju6676WriteData(~data);
         }
      }
      // 1px gap between chars
      if(nju6676FontColor == WHITE) {
         nju6676WriteData(0x00);
      } else {
         nju6676WriteData(0xFF);
      }
      nju6676GotoXY(x, nju6676Coord.y+8);
   }
   nju6676GotoXY(x+width+1, y);

   return 0;
}

void nju6676Puts(char* str) {
   int x = nju6676Coord.x;
   while(*str != 0) {
      if(*str == '\n') {
         nju6676GotoXY(x, nju6676Coord.y+nju6676FontRead(nju6676Font+FONT_HEIGHT));
      } else {
         nju6676PutChar(*str);
      }
      str++;
   }
}

uint8_t nju6676CharWidth(char c) {
   uint8_t width = 0;
   uint8_t firstChar = nju6676FontRead(nju6676Font+FONT_FIRST_CHAR);
   uint8_t charCount = nju6676FontRead(nju6676Font+FONT_CHAR_COUNT);

	if (FONT_LENGTH == 0)
	{
		width = nju6676FontRead(nju6676Font+FONT_FIXED_WIDTH);
	} else {
		// read width data
		if(c >= firstChar && c < (firstChar+charCount)) {
			c -= firstChar;
			width = nju6676FontRead(nju6676Font+FONT_WIDTH_TABLE+c)+1;
		}
	}

   return width;
}

uint16_t nju6676StringWidth(char* str) {
   uint16_t width = 0;

   while(*str != 0) {
      width += nju6676CharWidth(*str++);
   }

   return width;
}

void nju6676PrintNumber(long n)
{
	unsigned char buf[10];  // prints up to 10 digits  
	unsigned char i=0;
	if(n==0)
		nju6676PutChar('0');
	else{
		if(n < 0){
			nju6676PutChar('-');
			n = -n;
		}
		while(n>0 && i <= 10){
			buf[i++] = n % 10;  // n % base
			n /= 10;   // n/= base
		}
		for(; i >0; i--)
			nju6676PutChar((char) (buf[i-1] < 10 ? '0' + buf[i-1] : 'A' + buf[i-1] - 10));	  
	}
}

void nju6676DrawBitmap(uint8_t x, uint8_t y, const uint8_t *bitmap, uint8_t w, uint8_t h, uint8_t color)
{
	uint8_t i, j;
	for (j=0; j<h; j++) {
		for (i=0; i<w; i++ ) {
			if((bitmap[i + (j/8) * w]) & (1<<(j % 8))) {
				nju6676SetDot(x+i, y+j, color);
			}
		}
	}

  updateBoundingBox(x, y, x+w, y+h);
}

void nju6676Display(void)
{
	uint8_t PageNum, ColumnNum;
	nju6676WriteCommand(0x40); // line set
// 	nju6676WriteCommand(0xAE);
	for (PageNum=0; PageNum<8; PageNum++)
	{
		nju6676WriteCommand(0xB0 | PageNum); // page address set
		nju6676WriteCommand(0x10); // column upper set
		nju6676WriteCommand(0x04); // column lower set
// 		nju6676GotoXY(0,PageNum*8);
		for (ColumnNum = 0; ColumnNum < 128; ColumnNum++)
		{
			bcm2835_gpio_write(LCD_A0, HIGH);
			bcm2835_spi_transfer(DDRAM[128*PageNum + ColumnNum]);
		}
	}
// 	nju6676WriteCommand(0xAF);
}

